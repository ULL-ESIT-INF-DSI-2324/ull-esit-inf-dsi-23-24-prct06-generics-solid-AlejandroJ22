[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/G0JN8jPZ)

[![Coverage Status](https://coveralls.io/repos/github/ULL-ESIT-INF-DSI-2324/ull-esit-inf-dsi-23-24-prct06-generics-solid-AlejandroJ22/badge.svg?branch=main)](https://coveralls.io/github/ULL-ESIT-INF-DSI-2324/ull-esit-inf-dsi-23-24-prct06-generics-solid-AlejandroJ22?branch=main)

Ejercicio 1: no se impelmenta el patron *no me acuerdo* porque quisieramos tener varias cajas en lugar de una sola que se vaya modificando. Se implementa una clase generica Houseware que solo necesita de una string como nombre para poder ser instanciada y se decide hacer así por si acaso en el furtuo queremos tener diferentes tipos de muebles en lugar de un único tipo genérico. No sabía muy bien por dodne tirar de este ejercicio. No sabia como implementar el uso de un map para asi poder aplicar lo visto en clase durante la anterior semana.

Ejercicio 2: componentes necesarios de una factura: https://www.anfix.com/blog/como-hacer-facturas/informacion-en-facturas, se creo una clase abstracta desde la cual sus hijospuedan implementar su funcionalidad. Se crea un metodo tostring en lugar de un metodo print void para poder ejecutar los test de manera mas simple. Se aplica DIP (dependency inverse principle) ya que hay una gran clase abstracta que representa todo lo que tiene que tener una factura, en la cuál sus subclases implementaran su funcionamiento, por lo que nunca tendremos que modificar su funcionalidad sino añadir clases que implementen lo que queremos.

Ejercicio 3: rompe el principio de responsabilidad única ya que en una misma clase se encarga de leer y de escribir un archivo, cuando debería de depender de clases hijas para implementar esos metodos, adeás aprovecho esto para decir que tampoco cumple con el principio de dependencia inversa por lo ya dicho y ademas rompe el principio de segregación de la interfaz. Se añade una interfaz para FileManager, se cambia el atributo filePath a protected en lugar de private, para que pueda ser usado por las clases hijas. Como todavía no he experimentado lo suficiente con la lectura y escritura de archivos usando TypeScript no se muy bien como ejecutar los tests así que hay ciertas lineas de código que en los test no se alcanza a comprobar que es cunado falla la lectura o escritura de un archivo.

Ejercicio 4: creo que viola principalmente el principio de responsabilidad única. Las clases Printer, Scanner y PrinterScanner están combinando la funcionalidad de imprimir y escanear, esas funcionalidades no deberian de declararse en una clase cuando no se pretende que se utilicen, si queremos cumplir con el SRP debemos crear varias interfaces para seguir cumpliendo con el ISP que previamente no era omitido. Tambien debe de implementar una clase abstracta que defina sus metodos por sus hijos.se añaden tres tipos de clase, el que solo puede imprimir, el que solo puede escanear, y el que hace ambas acciones.

Ejercicio 5: lo primero es que no cumple con el principio de segregación de interfaces, ya que no hay ninguna interfaz implementada, luego podemos implementar una interfaz que se use como tipo del atributo privado de la case notifier para hacer nuestro código mucho más legible que usando una composición de tipos de las otras dos clases, ya que ambas clases son bastante parecidas, pero creo que para este programa es mucho mejor crear una clase abstracta que implemente de diferente manera el metodo sendNotification en sus dos hijos.

Ejercicio PE:

Nota en el ejercicio 5 hubo un problema al llamar a la interfaz Notification ya que ya hay una API definida que implementaba de manera muy diferente la interfaz